commit 04a7ba0862016eb66d9482641eb6d137d1c89f7a
Author: Shinichi Sato <hyotang.karakoma@gmail.com>
Date:   Sat Aug 11 13:38:51 2018 +0900

    First commit.

diff --git a/matrix-case.asd b/matrix-case.asd
new file mode 100644
index 0000000..64eb761
--- /dev/null
+++ b/matrix-case.asd
@@ -0,0 +1,8 @@
+; vim: ft=lisp et
+(in-package :asdf)
+(defsystem :matrix-case
+  :components ((:file "matrix-case")))
+
+;; The form below is added by JINGOH.GENERATOR.
+(defmethod component-depends-on((o test-op) (c (eql (find-system "matrix-case"))))
+  (append (call-next-method)'((test-op "matrix-case.test"))))
diff --git a/matrix-case.lisp b/matrix-case.lisp
new file mode 100644
index 0000000..a285238
--- /dev/null
+++ b/matrix-case.lisp
@@ -0,0 +1,121 @@
+(defpackage :matrix-case(:use :cl)
+  (:export
+    #:matrix-case
+    #:matrix-ecase
+    #:matrix-ccase
+    #:matrix-typecase
+    #:matrix-etypecase
+    #:matrix-ctypecase
+    ))
+(in-package :matrix-case)
+
+(defmacro defmatrix(underlying)
+  `(DEFMACRO ,(intern(format nil "MATRIX-~A"underlying))
+     ((&REST TARGETS)&BODY CLAUSES)
+     (FLET((CANONICALIZE(CLAUSES)
+	     (LET((OTHERWISE(FIND 'OTHERWISE CLAUSES
+				  :KEY #'CAR :TEST #'EQ :FROM-END T)))
+	       (IF OTHERWISE
+		 (VALUES (DELETE 'OTHERWISE CLAUSES
+				 :KEY #'CAR :FROM-END T :COUNT 1)
+			 (LIST (CONS T (CDR OTHERWISE))))
+		 (VALUES CLAUSES NIL))))
+	   )
+       ;; trivial syntax check.
+       (ASSERT (LOOP :FOR (CANDIDATES) :IN CLAUSES
+		     :WITH LENGTH = (LENGTH TARGETS)
+		     :ALWAYS (IF(EQ 'OTHERWISE CANDIDATES)
+			       t
+			       (= LENGTH (LENGTH CANDIDATES))))
+	       ()
+	       "TARGETS length does not match CANDIDATES length.~%~S~S"
+	       TARGETS (MAPCAR #'CAR CLAUSES))
+       ;; body
+       (CAR(MULTIPLE-VALUE-CALL #'MATRIX ',underlying TARGETS (CANONICALIZE CLAUSES))))))
+
+(defun matrix(underlying targets clauses default)
+  (if(null targets)
+    (if(< 1 (length clauses))
+      (error "Matrix impl bug:~%targets = ~S~%clauses = ~S"targets clauses)
+      (cdar clauses))
+    (labels((make-form(assoc)
+	      (destructuring-bind(type . branches)assoc
+		(if branches
+		  `(,type ,@(matrix underlying (cdr targets)
+				    branches
+				    default))
+		  (error "Impl bug: no branches~%assoc = ~S"assoc))))
+	    )
+      (let((var (gensym))
+	   (c(mapcar #'make-form (canonicalize(integrate-candidates clauses underlying)))))
+	`((LET((,var ,(car targets)))
+	    (,underlying ,var
+	      ,@c
+	      ,@(when(and default
+			  (not(eq t (caar(last c)))))
+		  default))))))))
+
+#++
+(defun integrate-candidates(clauses)
+  (loop :for (candidates . body) :in clauses
+	:for assoc = (assoc (car candidates) acc :test #'equal)
+	:if assoc
+	:do (push `(,(cdr candidates),@body)
+		  (cdr (assoc (car candidates) acc :test #'equal)))
+	:else
+	:collect (list (car candidates)
+		       `(,(cdr candidates),@body))
+	:into acc
+	:finally (return (mapcar (lambda(assoc)
+				   (rplacd assoc (nreverse(cdr assoc))))
+				 acc))))

+(defun integrate-candidates(clauses underlying)
+  (labels((rec(clauses &optional (acc (make-hash-table :test #'equal)))
+	    (if(endp clauses)
+	      (do-return acc)
+	      (body (car clauses)(cdr clauses)acc)))
+	  (do-return(acc)
+	    (loop :for list :being :each :hash-value :of acc :using (:hash-key key)
+		  :collect (cons key(nreverse list))))
+	  (body(clause rest acc)
+	    (destructuring-bind(candidates . body)clause
+	      (if(find underlying '(typecase etypecase ctypecase) :test #'eq)
+		(rec rest (integrate (car candidates)(cdr candidates) body acc))
+		(if(atom (car candidates))
+		  (rec rest (integrate (car candidates)(cdr candidates) body acc))
+		  (rec rest (reduce (lambda(acc candidate)
+				      (integrate candidate (cdr candidates)body acc))
+				    (car candidates)
+				    :initial-value acc))))))
+	  (integrate(candidate rest body acc)
+	    (setf (gethash candidate acc)
+		  (cons `(,rest ,@body) (gethash candidate acc)))
+	    acc))
+    (rec clauses)))

+(defun canonicalize(alist)
+  (labels((rec(alist &optional default acc)
+	    (if(endp alist)
+	      (do-return default acc)
+	      (body(car alist)(cdr alist)default acc)))
+	  (do-return(default acc)
+	    (assert(null(cdr default))) ; 1 element.
+	    (loop :for (key . rest) :in acc
+		  :collect `(,key ,@(delete-duplicates (append rest (cdar default))
+						       :key #'car
+						       :test #'equal
+						       :from-end T))
+		  :into result
+		  :finally (return (nreconc result default))))
+	  (body(clause rest default acc)
+	    (if(eq t (car clause))
+	      (rec rest (cons clause default)acc)
+	      (rec rest default (cons clause acc))))
+	  )
+    (rec alist)))
+
+(macrolet((defs(&rest symbols)
+	    `(PROGN ,@(mapcar (lambda(s)`(DEFMATRIX ,s))
+			      symbols))))
+  (defs typecase etypecase ctypecase case ecase ccase))
diff --git a/spec/matrix-case.lisp b/spec/matrix-case.lisp
new file mode 100644
index 0000000..d147010
--- /dev/null
+++ b/spec/matrix-case.lisp
@@ -0,0 +1,179 @@
+(defpackage :matrix-case.spec (:use :cl :jingoh :matrix-case))
+(in-package :matrix-case.spec)
+(setup :matrix-case)
+
+(common-requirements-about (MATRIX-TYPECASE MATRIX-ETYPECASE MATRIX-CTYPECASE)
+			   :as op)
+;;;; [Macro] MATRIX-TYPECASE MATRIX-ETYPECASE MATRIX-CTYPECASE
+
+#| Description: Like CL:TYPECASE, but represents nested typecases.|#
+#?(let((a 0))
+    (op(a 'key)
+      ((symbol integer):never)
+      ((integer symbol):yes!)
+      (otherwise :no!)))
+=> :YES!
+
+;; Only one cluase's body will be evaluated.
+#?(op(0 'sym 1)
+    ((symbol symbol symbol)(princ :sss))
+    ((symbol symbol integer)(princ :ssi))
+    ((symbol integer symbol)(princ :sis))
+    ((symbol integer integer)(princ :sii))
+    ((integer symbol integer)(princ :yes))
+    ((integer symbol symbol)(princ :iss))
+    ((integer integer integer)(princ :iii))
+    ((integer integer symbol)(princ :iis))
+    (otherwise (princ :otherwise)))
+:outputs "YES"
+
+;; Of course, we can use compound type specifier.
+#?(op(0)
+    (((and integer (eql 1))) :no)
+    (((member 0 2 4 6 8)) :yes))
+=> :YES
+
+;; T as wildcard
+#?(op("hoge" 0)
+    ((t symbol):no)
+    ((t fixnum):yes)
+    ((string string):no)
+    )
+=> :yes
+
+;; NOTE! wildcard is treated as last resort.
+#?(op("1" "2")
+    ((t string) :no)
+    ((string string):yes))
+=> :yes
+
+#?(op("1" "2")
+    ((string t) :no)
+    ((string string):yes))
+=> :yes
+
+#+syntax
+(MATRIX-TYPECASE targets &body clauses) ; => result
+
+;;; Arguments and Values:
+
+#| targets := (target*)
+   target := one lisp form
+|#
+;; every TARGET forms are evaluated only once.
+#?(op((princ 0)(princ 1))
+    ((symbol symbol):no)
+    ((integer symbol):no)
+    ((symbol integer):no)
+    (otherwise :no))
+:outputs "01"
+
+#| clauses := ((typespecifier+) &body body)
+   typespecifier := see hyperspec
+   body := implicit PROGN
+|#
+
+#| result := T |#
+
+#| Affected By: none |#
+
+#| Side-Effects: none |#
+
+#| Notes: |#
+;; Empty TARGETS is valid but, in such case CLAUSES must empty.
+;; Such form evaluated to be NIL by macro expansion.
+#?(op()()) => NIL
+#?(op()()) :expanded-to NIL
+#?(op()) => NIL
+#?(op()) :expanded-to NIL
+#?(op) :signals ERROR
+
+#| Exceptional-Situations: |#
+;; when TARGETS length and each TYPE-SPECIFIERS length is different,
+;; an error is signaled.
+#?(op(0)
+    ((symbol integer) :error))
+:signals ERROR
+
+#?(op(0 :hoge)
+    ((integer) :error))
+:signals ERROR
+
+;; others
+(requirements-about matrix-typecase)
+;; Default return value is NIL.
+#?(matrix-typecase(0)
+    ((symbol) :no))
+=> NIL
+
+;; Expanded examples.
+#?(matrix-typecase(0)
+    ((integer) :yes)
+    (otherwise :no))
+:expanded-to (let((var 0))
+	       (typecase var
+		 (integer :yes)
+		 (t :no)))
+
+#?(matrix-typecase(0 'sym)
+    ((symbol integer) :no)
+    ((integer symbol) :yes)
+    (otherwise :never))
+:expanded-to (let((var1 0))
+	       (typecase var1
+		 (symbol (let((var2 'sym))
+			   (typecase var2
+			     (integer :no)
+			     (t :never))))
+		 (integer (let((var3 'sym))
+			    (typecase var3
+			      (symbol :yes)
+			      (t :never))))
+		 (t :never)))
+
+(common-requirements-about (matrix-etypecase matrix-ctypecase)
+			   :as op)
+;; When any clause satisfies, an ERROR is signaled.
+#?(op(0)
+    ((symbol) :never))
+:signals ERROR
+
+(common-requirements-about (MATRIX-CASE MATRIX-ECASE MATRIX-CCASE)
+			   :as op)
+
+;;;; [Macro] MATRIX-CASE MATRIX-ECASE MATRIX-CCASE 
+
+#| Description: Like CL:CASE, but represents nested case.|#
+#?(op(0 1 2)
+    ((0 0 0):no)
+    ((0 1 1):no)
+    ((0 1 2):yes)
+    (otherwise :never))
+=> :YES
+#?(matrix-case(0 1)
+    (((0 2 4 6 8)(1 3 5 7 9)) :yes)
+    (((0 2 4 6 8)(0 2 4 6 8)) :no)
+    (((1 3 5 7 9)(0 2 4 6 8)) :no))
+=> :YES
+
+#+syntax
+(MATRIX-CASE (&rest keyform) &body clause*) ; => result
+
+;;; Arguments and Values:
+
+#| keyform := a form; evaluated to produce a test-key.|#
+
+#| clause := ((test-key*) body)
+   test-key := an object produced by evaluating keyform.
+   body := an implicit PROGN. |#
+
+#| result := the values returned by the body in the matching clause. |#
+
+#| Affected By: none |#
+
+#| Side-Effects: none |#
+
+#| Notes: |#
+
+#| Exceptional-Situations: |#
+
diff --git a/spec/matrix-case.test.asd b/spec/matrix-case.test.asd
new file mode 100644
index 0000000..3363dc4
--- /dev/null
+++ b/spec/matrix-case.test.asd
@@ -0,0 +1,5 @@
+; vim: ft=lisp et
+(in-package :asdf)
+(defsystem :matrix-case.test :depends-on (:jingoh "matrix-case") :components
+ ((:file "matrix-case")) :perform
+ (test-op (o c) (symbol-call :jingoh :examine :matrix-case)))
